# Language Documentation

In this document we clearly document the entirety of the Historia Language.

## The Idea
Historia is a language meant to make it easy to develop branching stories like Life is Strange or Detroit: Become Human. This way, the story logic can be seperated from the game logic, tested independently and embedded cleanly into the game.

The story is developed in Historia code files that are then compiled into C#. The imperative Historia code is translated into a single class called a state machine.

## The State Machine
The Historia state machine is C# class that implements the `Historia.IStory<TOutput, TOption>` interface, that looks like the following:
```cs
interface IStory<TOutput, TOption>
{
    bool Finished { get; }

    TOutput Output { get; }

    ImmutableArray<TOption> Options { get; }

    bool TryContinue();

    bool TryContinueWithOption(int option);

    byte[] Save();
}
```

A story also has the static methods `Story BeginNew()` to start at the beginning and `bool TryLoad(byte[] bytes, out Story story)` to load the story from a byte array that was previously output from the `Save()` method.

If the `Options` array is empty, we have a so called linear state, so we can call `TryContinue` and get back `true`, which updates the output value and the options. If we use `TryContinueWithOption` instead, we get back `false` and nothing happens. On the other hand, if we do have options, so `Options` is not empty, calling `TryContinue` does nothing, as we have different options on how to continue and need to select the one we want to use. This typically represents a choice in the story. So we need to use `TryContinueWithOption` and give that the index of the option from the `Options` array we want to select. If that all went well, we get back `true` and are in the next state.

If `Finished` is true, we have reached the end and can't continue.

The state machine handles all the state transitions in the background, so we do not need to worry about that at all. All the logic is described in the Historia file from which the state machine is generated.

The generic type parameters `TOutput` and `TOption` are filled in by the code generator. Typically, the Historia scripts will define new types for the concrete project that the Historia compiler will generate as well.

Let's see an example of this in action:

```cs
IStory<string, string> myStory = Story.Begin(); // Story is the state machine class generated by the Historia compiler

while (!myStory.Finished)
{
    if (myStory.Options.Length == 0)
    {
        Console.WriteLine(myStory.Output);
    }
    else
    {
        Console.WriteLine("Make a choice:")
        
        for (int i = 0; i < myStory.Options.Length; i++)
        {
            Console.WriteLine($"[{i}] {myStory.Options[i]}");
        }

        int choice;

        do
        {
            Console.Write(">> ");

            choice = int.Parse(Console.ReadLine());
        } while (!myStory.TryContinueWithOption(choice));
    }
}
```

Just a quick word of warning: The state machine is very efficient but at the cost of being completely unreadable. So don't try to look up the class and understand how this works. It's just magic numbers all over the place. Read the Historia code instead to get what is going on.

## States
Now that we know what happens with the Historia code after it is compiled, we are ready to look at the code itself.

There is some boilerplate we need right now that will only be clear after reading the next parts of the documentation, so just hang on. The important part happens inside of the main scene.

Let's look at a very simple example:

```
setting OutputType: String;

scene main
{
    output "Hello World";
    output "Goodbye World"; 
}
```

This code contains two states, each defined by the `output` statement. Both of these states are linear states for the sake of the state machine. The state machine starts in the state `output "Hello World";`, so the `Output` property is set to the string `"Hello World"`. Once continued, the `Output` is changed to `"Goodbye World"`, and if you continue once again, the story is done and `Finished` is set to true.

### Switches
Next, we'll look at branching. While outputs are very important, only having them is just a linear story, but we want to have choices and stuff. So let's look at switch statements:

```
setting OutputType: String;
setting OptionType: String;

scene main
{
    switch ("What time of day is it?")
    {
        option ("Morning")
        {
            output "Good morning World";
        }

        option ("Evening")
        {
            output "Good evening World";
        }
    }
}
```

In this example, we make the choice which time of day we have and depending on the option that is selected, we output different text.

The switch itself is a state, so it has an output value, just like a regular output statement that also lands in the `Output` property of the state machine. However, since we have options now, the `Options` property now has two values: `"Morning"` and `"Evening"`. Since `"Morning"` is at index `0` in the array, if you use `TryContinueWithOption(0)`, you get into the `"Good morning World"` state, and similarly for the other option.

### Outcomes
Right now, we can make choices and have different stuff happen for different choices. However, for a true branching story, it has to be possible to save choices that were previously made and make them have consequences later on in the story. This is what outcomes are for.

An outcome is declared like so:

```
outcome RelationshipStatus { Couple, Friends, Enemies };
```

Depending on where in the story you are, you can then set the outcome to the appropriate option:

```
setting OutputType: String;
setting OptionType: String;

outcome RelationshipStatus { Couple, Friends, Enemies };

scene main
{
    output "Alice: I love you Beverly.";

    switch ("What do you answer her?")
    {
        option ("I love you too!")
        {
            output "Beverly: I love you too, Alice. I want to be with you.";
            output "Alice: I want nothing less.";
            output "And they kiss.";
            RelationshipStatus = Couple;
        }

        option ("I like you as a friend.")
        {
            output "Beverly: Honestly, Alice. I like you a lot, but not in this way.";
            output "Alice: I understand.";
            RelationshipStatus = Friends;
        }

        option ("I hate you!")
        {
            output "Beverly: I hate you, Alice. I hate you so much.";
            output "Alice: Fuck you!";
            RelationshipStatus = Enemies;
        }
    }
}
```

Don't mock the writing, this is obviously a toy example. Usually I'm better than that (I hope).

As you can see, depending on the choice that was made, there are different outcomes. Setting an outcome is not a state. In this case, if we are just before the outcome is set in our state machine, continuing sets the outcome and immediately progresses to the next state.

### Branch on

We can reference outcomes later in the story using a `branchon` statement.

```
setting OutputType: String;
setting OptionType: String;

outcome RelationshipStatus { Couple, Friends, Enemies };

scene main
{
    // all of the previous conversation...

    // later...
    output "Alice: Oh, Beverly.";

    branchon RelationshipStatus
    {
        option Couple
        {
            output "Alice: I missed you.";
            output "They kiss. Gross.";
        }

        option Friends
        {
            output "Alice: Everything fine?";
            output "Beverly: Yeah, just a bit stressful, you know?";
        }

        option Enemies
        {
            output "Alice: What the fuck are you doing here?";
            output "Beverly: What are you doing here? Fuck off!";
        }
    }
}
```

Something very important: The `branchon` statement does not represent a state. What that means is, that when we are in the state `"Alice: Oh, Beverly."`, you have to use `TryContinue()`. In the background, Historia will look up the outcome that happened and depending on that, progress. So, if the outcome was `Couple`, for example, the next state after `"Alice: Oh, Beverly."` is `"Alice: I missed you."` with nothing in between.

The Historia compiler will require two things: First of all, once we hit the `branchon` statement, there has to be an outcome selected. The outcome may be set in a more complicated way than shown above, so it may be possible to have a path through the story where the outcome is not set but the `branchon` statement is reached. That is an error and the story will not compile. To fix that, the outcome may have a default option that is specified like so:

```
outcome RelationshipStatus { Couple, Friends, Enemies } default Couple;
```

Check yourself whether that makes sense in your situation.

The second thing the compiler requires is that an outcome is never set more than once. So the following code will very clearly produce an error:

```
setting OutputType: String;

outcome RelationshipStatus { Couple, Friends, Enemies };

scene main
{
    RelationshipStatus = Couple;
    RelationshipStatus = Friends;
}
```

So, to recap, an outcome has to be set at least once, when it is branched on, and may not be set at all at a point where it is set. The only exception is a default option: If an outcome has a default option, it may still be set once.

Both of these requirements follow the same rule: If the compiler can prove that everything is fine, the code will compile. If the compiler cannot prove that, you will get an error, even though the specific code may not violate the requirements. This is a problem that will never ever be solved completely (google Halting Problem), so your perfectly good code may produce an error. In that case, it is typically pretty easy to solve that, either by providing a default option or by restructuring your code to be cleaner.

Another thing to note is that the outcome was declared at the top level. This way, it can be referenced everywhere in your code. You may also declare your outcome inside a scene. In that case, the outcome can only be referenced from inside of that scene (this will be important once you have multiple scenes).

### Named switches
Outcomes can be arbitrarily complicated, but just as with the example above, the 90% case is simpler. It ties each outcome to a single choice. To make this easier, Historia provides the ability to name switches and its options.

Take this code:

```
setting OutputType: String;
setting OptionType: String;

scene main
{
    switch MySwitch ("My switch")
    {
        option A ("A")
        {
            output "AAA";
        }

        option B ("B")
        {
            output "BBB";
        }
    }
}
```

For brevity this is not a full story.

This code is completely equivalent to the following code:

```
setting OutputType: String;
setting OptionType: String;

scene main
{
    outcome MySwitch { A, B };

    switch ("My switch")
    {
        option ("A")
        {
            MySwitch = A;
            output "AAA";
        }

        option ("B")
        {
            MySwitch = B;
            output "BBB";
        }
    }
}
```

A named switch can also have a default option like so:

```
switch MySwitch ("My switch") default A
{
    ...
}
```

Notice that the outcome is declared in the scene, not at the top level, so the switch is not available outside of the scene. To have a globally available named switch, you can use a concept of a switch carrying out an outcome. So if you have a global outcome, a scene may have a switch with that exact name and those exact options:

```
setting OutputType: String;
setting OptionType: String;

outcome MySwitch { A, B };

scene main
{
    switch MySwitch ("My switch")
    {
        option A ("A")
        {
            output "AAA";
        }

        option B ("B")
        {
            output "BBB";
        }
    }
}
```

In this case, the outcome is set appropriately for each option.

## Scenes
In Historia, scenes can be understood as methods, to seperate code and give it a name:

```
setting OutputType: String;

scene main
{
    call Scene1;
    call Scene2;
}

scene Scene1
{
    output "This is scene 1";
}

scene Scene2
{
    output "This is scene 2";
}
```

We always need a `main` scene. This is where the execution begins. Other scenes may be called, using the `call` keyword.

Scenes can absolutely be called in more than one place:

```
setting OutputType: String;
setting OptionType: String;

scene main
{
    switch ("Which scene to call?")
    {
        option ("Scene 1")
        {
            call Scene 1;
        }

        option ("Scene 2")
        {
            call Scene 2;
        }

        option ("Both")
        {
            call Scene1;
            call Scene2;
        }
    }
}

scene Scene1
{
    output "This is scene 1";
}

scene Scene2
{
    output "This is scene 2";
}
```

A scene can also run more than once:

```
setting OutputType: String;

scene main
{
    call OtherScene;
    call OtherScene;
}

scene OtherScene
{
    output "Some scene";
}
```

There are restrictions however: Due to the structure of Historia, we require that scenes are not recursive. That means the following code will produce errors:

```
scene A
{
    call A;
}

scene B
{
    call C;
}

scene C
{
    call B;
}
```

One error happens because scene A calls itself, and the other error happens because scene B calls itself, just indirectly. By calling scene C, which calls scene B, scene B calls itself which is not allowed.

### Scopes
A scene defines a new scope. Outcomes and named switches in that scene can only be referenced inside of that scene. What's more, each option also defines its own scope, so if you declare an outcome in an option but want to use it outside of the corresponding `switch` or `branchon`, this will produce an error:

```
setting OutputType: String;
setting OptionType: String;

scene main
{
    switch ("My switch")
    {
        option ("A")
        {
            outcome MyOutcome { X, Y, Z };
        }
    }

    MyOutcome = X; // error
}
```

What that also means is that in seperate scopes the same name may be used, whereas usually a name cannot be used for multiple symbols in the same scope.

```
setting OutputType: String;
setting OptionType: String;

scene main
{
    outcome SomeOutcome { A, B };
    
    switch ("My switch")
    {
        option ("A")
        {
            outcome MyOutcome { X, Y, Z };
        }

        option ("B")
        {
            outcome MyOutcome { A, B, C }; // okay
            outcome SomeOutcome { X, Y }; // not okay, there is something called MyOutcome already
        }
    }
}
```

Additionally, names have to be unique among everything that can be named, so a scene cannot have the same name as an outcome, to avoid confusion.

```
setting OutputType: String;

scene main
{
}

outcome A { X, Y, Z };
scene A { } // error: there is something called A in scope already
```

## Types
Finally, let's talk about types. You have probably been ignoring these `setting OutputType: String` and `setting OptionType: String` very hard until this point. Well, you aren't so lucky anymore.

Historia has the builtin types `Int` and `String`, that correspond to the C# types `int` and `string`. You may however declare your own types.

### Records
Up to this point we have just output strings. This may be good enough for a toy example, but in practice we might need more information. To bundle up information, you can declare a record. For example:

```
record Line
{
    Text: String;
    Character: String;
}
```

`Text` and `Character` are what we call properties of the record, and each property has a type, which can be any type including other records.

If you set your new record as the output type, like `setting OutputType: Line;`, you can now output a line, like so:

```
record Line
{
    Text: String;
    Character: String;
}

setting OutputType: Line;

scene main
{
    output Line("Hello World", 1);
    output Line("Hello Antonia", 2);
}
```

In the `Line("Hello World", 1)` expressions, the subexpressions represents the values for each of the properties, in exactly the order they were specified above. You can also add the name of the properties, to make this clearer:

```
output Line(Text = "Hello World", Character = 1);
```

The order still needs to stay intact.

The code generator will turn a record into a C# struct with the same name as the record.

### Unions
Records are usually not enough. Often you might want to output a lot of different things, depending on context. This is what unions are for. 

Take the following code:
```
record Line
{
    Text: String;
    Character: String;
}

record Choice
{
    Text: String;
    Severity: Int;
}

record StageDirection
{
    Text: String;
}

union Output: Line, Choice, StageDirection;

setting OutputType: Output;

scene main
{
    output Line("Hello World", 1);
    output StageDirection("Zoom out");
    
    switch (Choice("What to do?", 2)) { }
}
```

As you can see, different records can be output, as all of those records are of the type `Output` because that is a union of all of these types.

The code generator will generate unions as structs. In this case, the struct will look like this:

```cs
struct Output
{
    public Line Line { get; }

    public bool IsLine { get; }

    public Choice Choice { get; }

    public bool IsChoice { get; }

    public StageDirection StageDirection { get; }

    public bool IsStageDirection { get; }
}
```

### Enums
Enums are types where the value is one of finitely many options. They can be used to define characters, for example:

```
enum Character
{
    Alice,
    Beverly,
    Narrator
}

record Line
{
    Text: String;
    Character: Character;
}
```

You can reference enums using the name of the value:

```
output Line("I love you, Beverly!", Alice);
```

Enums are very straightforwardly generated as C# enums.
